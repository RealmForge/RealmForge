# 개발 일지 - 2025-12-16

## 개요

오늘 작업의 주요 목표:
1. ECS 시스템 최적화 (ISystem 변환, Burst 컴파일)
2. NetCode 환경에서의 렌더링 문제 해결
3. MarchingCube 구현을 위한 동적 메시 생성 검증

---

## 1. DebugVisualizationSystem ISystem 변환

### 배경
기존 `SystemBase` (class 기반)를 `ISystem` (struct 기반)으로 변환하여 Burst 컴파일 지원 및 성능 최적화.

### 변경 내용
```csharp
// Before
public partial class DebugVisualizationSystem : SystemBase
{
    protected override void OnUpdate() { ... }
}

// After
[BurstCompile]
public partial struct DebugVisualizationSystem : ISystem
{
    [BurstCompile]
    public void OnUpdate(ref SystemState state) { ... }
}
```

### 주요 변경점
- `EntityManager` → `state.EntityManager`
- `BeginSimulationEntityCommandBufferSystem.Singleton`을 통한 ECB 획득
- `[BurstCompile]` 어트리뷰트 추가

---

## 2. PerlinNoiseJob 노이즈 값 범위 수정

### 문제
`noise.snoise()`가 `-1 ~ 1` 범위의 값을 반환하여 시각화 시 음수 값 처리 문제 발생.

### 해결
```csharp
// 0~1 범위로 매핑
return (noiseHeight / maxValue) * 0.5f + 0.5f;
```

---

## 3. ChunkManager 렌더링 문제 해결

### 문제 현상
- `NoiseTestAuthoring` (SubScene)으로 생성된 큐브는 렌더링됨
- `ChunkManager` (런타임)로 생성된 큐브는 렌더링 안됨
- Inspector에서는 Entity 생성 확인됨

### 원인 분석
디버그 로그 추가하여 World 이름 확인:
```
[DebugVisualization] World: ServerWorld, Chunk int3(0,0,0): 317 cubes created
[ChunkManager] Spawned chunk at int3(0,0,0) in World: ServerWorld  ← 문제!
```

**원인**: `World.DefaultGameObjectInjectionWorld`가 NetCode 환경에서 `ServerWorld`를 반환.
`ServerWorld`는 렌더링을 수행하지 않음.

### 해결
```csharp
// ClientWorld를 명시적으로 찾아서 사용
foreach (var world in World.All)
{
    if (world.Name == "ClientWorld")
    {
        _targetWorld = world;
        break;
    }
}
```

### 학습 포인트
NetCode 환경에서는:
- **ClientWorld**: 렌더링 담당
- **ServerWorld**: 시뮬레이션만 담당
- 시각적 요소는 반드시 ClientWorld에 생성해야 함

---

## 4. CameraController 추가

### 기능
| 조작 | 키/마우스 |
|------|-----------|
| 이동 | W/A/S/D |
| 상승/하강 | E/Q |
| 빠른 이동 | Shift |
| 회전 | 마우스 우클릭 + 드래그 |
| 줌 | 마우스 스크롤 |

### 파일 위치
`Assets/Scripts/Debug/CameraController.cs`

---

## 5. 동적 메시 생성 테스트 (MarchingCube 준비)

### 목적
MarchingCube 알고리즘 구현 전, DOTS 환경에서 동적 메시 생성 및 렌더링 검증.

### 아키텍처 결정

**질문**: MarchingCube에서 메시를 어떻게 구성할 것인가?
- 방법 1: 패턴별 메시 인스턴싱
- 방법 2: 한 청크 = 한 메시

**결론**: **한 청크 = 한 메시** 방식 채택

**이유**: MarchingCube에서 정점 위치는 밀도값에 따라 **보간(interpolation)**됨.
같은 패턴이라도 실제 정점 위치가 다르므로 단순 인스턴싱 불가.

### 구현 구조

```
Assets/Scripts/Debug/
├── Vertex.cs                 # 정점 구조체 (Position, Normal)
├── TriangleMeshJob.cs        # 100개 삼각형 생성 Burst Job
├── ChunkMeshSpawner.cs       # 4개 청크 ECS 엔티티 생성
└── Components/
    └── ChunkMeshData.cs      # 청크 식별 컴포넌트
```

### 핵심 코드

**Vertex 구조체** - GPU 메모리 레이아웃 보장:
```csharp
[StructLayout(LayoutKind.Sequential)]
public struct Vertex
{
    public float3 Position;
    public float3 Normal;
}
```

**메시 생성 (MeshDataArray + Job)**:
```csharp
var meshDataArray = Mesh.AllocateWritableMeshData(1);
var job = new TriangleMeshJob { MeshData = meshDataArray[0], ... };
job.Schedule().Complete();
Mesh.ApplyAndDisposeWritableMeshData(meshDataArray, mesh);
```

**ECS 엔티티 렌더링**:
```csharp
RenderMeshUtility.AddComponents(
    entity,
    entityManager,
    renderMeshDescription,
    renderMeshArray,
    MaterialMeshInfo.FromRenderMeshArrayIndices(0, 0)
);
```

### 테스트 결과
- 4개 청크 (각 100개 삼각형) 정상 렌더링 확인
- ClientWorld 타겟팅으로 NetCode 환경에서도 동작

---

## 6. CLAUDE.md 프로젝트 설정

### 목적
Claude Code AI 어시스턴트와의 협업을 위한 프로젝트 규칙 정의.

### 주요 규칙
1. **커뮤니케이션**: 큰 작업 시 세부 지시사항 확인
2. **ECS 개발**: 기본 `ISystem` 사용, `SystemBase`는 허락 필요
3. **비동기 Job**: 사용 전 계획 및 필요성 설명 후 승인

### 코딩 스타일
- PascalCase: 클래스, 메서드, public 필드
- camelCase: private 필드, 로컬 변수 (언더스코어 미사용)
- 인터페이스: `I` 접두사
- Boolean: `is/has/can` 접두사

---

## 다음 작업 예정

- [ ] MarchingCube 알고리즘 구현
- [ ] 청크 LOD 시스템
- [ ] 청크 풀링 및 재사용
